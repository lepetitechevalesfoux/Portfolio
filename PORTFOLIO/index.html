<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrollbare Pose Trails</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Helvetica+Neue:wght@400;700&display=swap');
        
        body { 
            margin: 0; 
            background: #ffffff; 
            font-family: 'Helvetica Neue', sans-serif;
            padding-top: 56px;
        }
        canvas { 
            display: block; 
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            pointer-events: none; /* Ermöglicht Scrollen durch den Canvas */
            z-index: 1;
        }
        .panel {
            position: relative;
            z-index: 2;
            width: 80vw;
            height: 60vh;
            max-width: 800px;
            margin: 100px auto;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Kein Hintergrund, keine Box-Shadow - komplett unsichtbar */
        }
        .panel h1 {
            font-size: 5vw;
            font-weight: 700;
            margin: 0;
            letter-spacing: 2px;
        }
        #debug {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: #000;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            background: rgba(255,255,255,0.9);
            padding: 5px;
            border: 1px solid #000;
            max-width: 300px;
            z-index: 100;
        }
        .navigation {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            align-items: center;
            padding: 16px 24px;
            height: 56px;
            background: rgba(255,255,255,0.9);
            backdrop-filter: saturate(180%) blur(8px);
        }
        
        .navigation a {
            color: #000;
            text-decoration: none;
            margin: 0;
            font-weight: 500;
            text-align: center;
            transition: color 0.3s ease;
        }
        
        .navigation a:hover {
            color: #666;
        }
        
        .navigation a.active {
            color: #000;
            font-weight: 700;
        }
        
        .panel:first-of-type {
            height: calc(100vh - 56px);
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <nav class="navigation">
        <a href="index.html" class="active">Home</a>
        <a href="cv.html">CV</a>
        <a href="works.html">Works</a>
        <a href="contact.html">Contact</a>
    </nav>
    
    <div id="debug">Warte auf Pose-Erkennung...</div>
    
    <canvas id="pose-canvas"></canvas>
    <video id="webcam" style="display: none;"></video>
    
    <div class="panel" style="color: rgb(255, 0, 0);">
        <h1>JOSHUA LIECK</h1>
    </div>
    
    <div class="panel" style="color: rgb(0, 255, 0);">
        <h1>JOSHUA LIECK</h1>
    </div>
    
    <div class="panel" style="color: rgb(0, 0, 255);">
        <h1>JOSHUA LIECK</h1>
    </div>

    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>

    <script>
        // Debug-Element
        const debugEl = document.getElementById('debug');
        
        // Canvas Setup
        const canvas = document.getElementById('pose-canvas');
        const ctx = canvas.getContext('2d');
        
        // Canvas-Größe anpassen und Hintergrund zeichnen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Weißen Hintergrund zeichnen (nur beim Start oder beim Leeren)
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Trail-System für verschiedene Körperteile
        const poseTrails = {
            nose: [],
            leftShoulder: [],
            rightShoulder: [],
            leftElbow: [],
            rightElbow: [],
            leftWrist: [],
            rightWrist: [],
            leftHip: [],
            rightHip: [],
            leftKnee: [],
            rightKnee: [],
            leftAnkle: [],
            rightAnkle: []
        };
        
        // MediaPipe Pose Setup
        const pose = new Pose({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
        });
        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        pose.onResults((results) => {
            if (results.poseLandmarks) {
                debugEl.textContent = "Pose erkannt!";
                
                // Wichtige Landmark-Indizes (MediaPipe Pose)
                const landmarks = results.poseLandmarks;
                
                // Körperteile aktualisieren und Linien zeichnen
                updateTrail('nose', landmarks[0]);
                updateTrail('leftShoulder', landmarks[11]);
                updateTrail('rightShoulder', landmarks[12]);
                updateTrail('leftElbow', landmarks[13]);
                updateTrail('rightElbow', landmarks[14]);
                updateTrail('leftWrist', landmarks[15]);
                updateTrail('rightWrist', landmarks[16]);
                updateTrail('leftHip', landmarks[23]);
                updateTrail('rightHip', landmarks[24]);
                updateTrail('leftKnee', landmarks[25]);
                updateTrail('rightKnee', landmarks[26]);
                updateTrail('leftAnkle', landmarks[27]);
                updateTrail('rightAnkle', landmarks[28]);
                
            } else {
                debugEl.textContent = "Keine Pose erkannt";
            }
        });
        
        // Hilfsfunktion zum Aktualisieren eines Trails und Zeichnen der Linie
        function updateTrail(trailName, landmark) {
            if (landmark && landmark.visibility > 0.5) {
                const x = landmark.x * canvas.width;
                const y = landmark.y * canvas.height;
                
                // Neue Position zum Trail hinzufügen
                poseTrails[trailName].push({x, y});
                
                // Linie zeichnen, wenn mindestens 2 Punkte vorhanden
                if (poseTrails[trailName].length > 1) {
                    const prevPoint = poseTrails[trailName][poseTrails[trailName].length - 2];
                    const currPoint = poseTrails[trailName][poseTrails[trailName].length - 1];
                    
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(prevPoint.x, prevPoint.y);
                    ctx.lineTo(currPoint.x, currPoint.y);
                    ctx.stroke();
                }
            }
        }
        
        // Webcam starten
        const webcam = new Camera(document.getElementById('webcam'), {
            onFrame: async () => {
                await pose.send({image: document.getElementById('webcam')});
            },
            width: 640,
            height: 480
        });
        
        webcam.start().then(() => {
            debugEl.textContent = "Webcam aktiviert - Warte auf Pose...";
        }).catch(err => {
            debugEl.textContent = "Webcam-Fehler: " + err.message;
        });
        
        // Canvas leeren mit 'c' Taste
        document.addEventListener('keydown', (e) => {
            if (e.key === 'c' || e.key === 'C') {
                // Hintergrund neu zeichnen (löscht alle Linien)
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Alle Trails leeren
                for (const trailName in poseTrails) {
                    poseTrails[trailName] = [];
                }
                
                debugEl.textContent = "Canvas geleert (C-Taste)";
            }
        });
        
        // Scroll-Event für vertikale Linien
        let lastScrollY = window.scrollY;
        
        window.addEventListener('scroll', () => {
            const currentScrollY = window.scrollY;
            const scrollDirection = currentScrollY > lastScrollY ? 'down' : 'up';
            const scrollDistance = Math.abs(currentScrollY - lastScrollY);
            
            // Für jeden aktiven Trail eine vertikale Linie zeichnen
            for (const trailName in poseTrails) {
                const trail = poseTrails[trailName];
                if (trail.length > 0) {
                    const lastPoint = trail[trail.length - 1];
                    
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(lastPoint.x, lastPoint.y);
                    
                    // Vertikale Linie in Scroll-Richtung
                    if (scrollDirection === 'down') {
                        ctx.lineTo(lastPoint.x, lastPoint.y + scrollDistance);
                    } else {
                        ctx.lineTo(lastPoint.x, lastPoint.y - scrollDistance);
                    }
                    
                    ctx.stroke();
                    
                    // Position des letzten Punktes aktualisieren
                    if (scrollDirection === 'down') {
                        lastPoint.y += scrollDistance;
                    } else {
                        lastPoint.y -= scrollDistance;
                    }
                }
            }
            
            lastScrollY = currentScrollY;
        });
    </script>
    <script>
        document.addEventListener('click', (event) => {
            if (event.target.closest('.navigation')) return;
            window.location.href = 'cv.html';
        });
    </script>
    <script>
        // Zufällige Farben für Joshua Lieck Panels beim Laden
        function randomColor() {
            const r = Math.floor(Math.random() * 256);
            const g = Math.floor(Math.random() * 256);
            const b = Math.floor(Math.random() * 256);
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        // Beim Laden der Seite alle Panels zufällig einfärben
        window.addEventListener('load', () => {
            const panels = document.querySelectorAll('.panel');
            panels.forEach(panel => {
                panel.style.color = randomColor();
            });
            // Speichere die erste Farbe für Konsistenz mit anderen Seiten
            if (panels.length > 0) {
                sessionStorage.setItem('nameColor', panels[0].style.color);
            }
        });
    </script>
    <script>
        // Unendliche Panels mit zufälligen Farben hinzufügen
        function randomColor() {
            const x = Math.floor(Math.random() * 256);
            const y = Math.floor(Math.random() * 256);
            const z = Math.floor(Math.random() * 256);
            return `rgb(${x}, ${y}, ${z})`;
        }

        function createPanel() {
            const panel = document.createElement('div');
            panel.className = 'panel';
            panel.style.color = randomColor();
            const h1 = document.createElement('h1');
            h1.textContent = 'JOSHUA LIECK';
            panel.appendChild(h1);
            return panel;
        }

        let isAppending = false;
        function maybeAppendPanels() {
            if (isAppending) return;
            const nearBottom = window.scrollY + window.innerHeight > document.documentElement.scrollHeight - 800;
            if (!nearBottom) return;
            isAppending = true;
            for (let i = 0; i < 5; i += 1) {
                document.body.appendChild(createPanel());
            }
            isAppending = false;
        }

        window.addEventListener('scroll', maybeAppendPanels);
        window.addEventListener('load', () => {
            // Initiale Erweiterung, damit genügend Inhalt vorhanden ist
            for (let i = 0; i < 3; i += 1) document.body.appendChild(createPanel());
        });
    </script>
</body>
</html>